"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RollupContract = exports.Node = exports.Assertion = exports.NodeState = exports.ExecutionState = void 0;
const hardhat_1 = require("hardhat");
const ethers_1 = require("ethers");
const zerobytes32 = '0x0000000000000000000000000000000000000000000000000000000000000000';
function bisectionChunkHash(start, length, startHash, endHash) {
    return hardhat_1.ethers.utils.solidityKeccak256(['uint256', 'uint256', 'bytes32', 'bytes32'], [start, length, startHash, endHash]);
}
function assertionHash(arbGasUsed, assertionRest) {
    return hardhat_1.ethers.utils.solidityKeccak256(['uint256', 'bytes32'], [arbGasUsed, assertionRest]);
}
function nodeHash(hasSibling, lastHash, assertionExecHash, inboxAcc) {
    return hardhat_1.ethers.utils.solidityKeccak256(['bool', 'bytes32', 'bytes32', 'bytes32'], [hasSibling, lastHash, assertionExecHash, inboxAcc]);
}
function assertionRestHash(totalMessagesRead, machineState, sendAcc, sendCount, logAcc, logCount) {
    return hardhat_1.ethers.utils.solidityKeccak256(['uint256', 'bytes32', 'bytes32', 'uint256', 'bytes32', 'uint256'], [totalMessagesRead, machineState, sendAcc, sendCount, logAcc, logCount]);
}
function challengeRootHash(execution, gasUsed, maxMessageCount) {
    return hardhat_1.ethers.utils.solidityKeccak256(['bytes32', 'uint256', 'uint256'], [execution, gasUsed, maxMessageCount]);
}
class ExecutionState {
    constructor(gasUsed, machineHash, inboxCount, sendCount, logCount, sendAcc, logAcc) {
        this.gasUsed = gasUsed;
        this.machineHash = machineHash;
        this.inboxCount = inboxCount;
        this.sendCount = sendCount;
        this.logCount = logCount;
        this.sendAcc = sendAcc;
        this.logAcc = logAcc;
    }
    challengeRestHash() {
        return assertionRestHash(this.inboxCount, this.machineHash, this.sendAcc, this.sendCount, this.logAcc, this.logCount);
    }
    challengeHash() {
        return assertionHash(this.gasUsed, this.challengeRestHash());
    }
    bytes32Fields() {
        return [this.machineHash, this.sendAcc, this.logAcc];
    }
    intFields() {
        return [this.gasUsed, this.inboxCount, this.sendCount, this.logCount];
    }
}
exports.ExecutionState = ExecutionState;
class NodeState {
    constructor(execState, proposedBlock, inboxMaxCount) {
        this.execState = execState;
        this.proposedBlock = proposedBlock;
        this.inboxMaxCount = inboxMaxCount;
    }
    hash() {
        return hardhat_1.ethers.utils.solidityKeccak256([
            'uint256',
            'bytes32',
            'uint256',
            'uint256',
            'uint256',
            'bytes32',
            'bytes32',
            'uint256',
            'uint256',
        ], [
            this.execState.gasUsed,
            this.execState.machineHash,
            this.execState.inboxCount,
            this.execState.sendCount,
            this.execState.logCount,
            this.execState.sendAcc,
            this.execState.logAcc,
            this.proposedBlock,
            this.inboxMaxCount,
        ]);
    }
    equals(other) {
        return this.hash() == other.hash();
    }
}
exports.NodeState = NodeState;
function buildAccumulator(base, hashes) {
    let acc = base;
    for (const h of hashes) {
        acc = hardhat_1.ethers.utils.solidityKeccak256(['bytes32', 'bytes32'], [acc, h]);
    }
    return acc;
}
class Assertion {
    constructor(beforeState, gasUsed, afterMachineHash, messages, sends, logs) {
        this.beforeState = beforeState;
        this.afterState = new ExecutionState(hardhat_1.ethers.BigNumber.from(this.beforeState.execState.gasUsed).add(gasUsed), afterMachineHash, hardhat_1.ethers.BigNumber.from(this.beforeState.execState.inboxCount).add(messages.length), hardhat_1.ethers.BigNumber.from(this.beforeState.execState.sendCount).add(sends.length), hardhat_1.ethers.BigNumber.from(this.beforeState.execState.logCount).add(logs.length), buildAccumulator(this.beforeState.execState.sendAcc, sends), buildAccumulator(this.beforeState.execState.logAcc, logs));
    }
    gasUsed() {
        return hardhat_1.ethers.BigNumber.from(this.afterState.gasUsed).sub(this.beforeState.execState.gasUsed);
    }
    bytes32Fields() {
        return [
            this.beforeState.execState.bytes32Fields(),
            this.afterState.bytes32Fields(),
        ];
    }
    intFields() {
        return [this.beforeState.execState.intFields(), this.afterState.intFields()];
    }
    executionHash() {
        return bisectionChunkHash(this.beforeState.execState.gasUsed, this.gasUsed(), this.beforeState.execState.challengeHash(), this.afterState.challengeHash());
    }
}
exports.Assertion = Assertion;
class Node {
    constructor(assertion, blockCreated, inboxMaxCount, nodeHash) {
        this.nodeHash = nodeHash;
        this.beforeState = assertion.beforeState;
        this.afterState = new NodeState(assertion.afterState, blockCreated, inboxMaxCount);
    }
    gasUsed() {
        return hardhat_1.ethers.BigNumber.from(hardhat_1.ethers.BigNumber.from(this.afterState.execState.gasUsed).sub(this.beforeState.execState.gasUsed));
    }
    checkTime(arbGasSpeedLimitPerBlock) {
        return this.gasUsed().div(arbGasSpeedLimitPerBlock).toNumber();
    }
    executionHash() {
        return bisectionChunkHash(this.beforeState.execState.gasUsed, this.gasUsed(), this.beforeState.execState.challengeHash(), this.afterState.execState.challengeHash());
    }
}
exports.Node = Node;
class RollupContract {
    constructor(rollup) {
        this.rollup = rollup;
    }
    connect(signerOrProvider) {
        return new RollupContract(this.rollup.connect(signerOrProvider));
    }
    newStake(overrides = {}) {
        return this.rollup.newStake(overrides);
    }
    async stakeOnNewNode(parentNode, assertion, afterInboxAcc, batchProof, prevNode) {
        if (!prevNode) {
            prevNode = parentNode;
        }
        const isChild = prevNode.afterState.equals(assertion.beforeState);
        const newNodeHash = nodeHash(!isChild, prevNode.nodeHash, assertion.executionHash(), afterInboxAcc);
        const tx = await this.rollup.stakeOnNewNode(newNodeHash, assertion.bytes32Fields(), assertion.intFields(), parentNode.afterState.proposedBlock, parentNode.afterState.inboxMaxCount, batchProof);
        const receipt = await tx.wait();
        if (receipt.logs == undefined) {
            throw Error('expected receipt to have logs');
        }
        const ev = this.rollup.interface.parseLog(receipt.logs[receipt.logs.length - 1]);
        if (ev.name != 'NodeCreated') {
            throw 'wrong event type';
        }
        const parsedEv = ev;
        const node = new Node(assertion, receipt.blockNumber, parsedEv.args.inboxMaxCount, newNodeHash);
        const event = parsedEv.args;
        return { tx, node, event };
    }
    stakeOnExistingNode(nodeNum, nodeHash) {
        return this.rollup.stakeOnExistingNode(nodeNum, nodeHash);
    }
    confirmNextNode(prevSendAcc, prevSendCount, sends, afterlogAcc, afterLogCount) {
        const messageData = hardhat_1.ethers.utils.concat(sends);
        const messageLengths = sends.map(msg => msg.length);
        return this.rollup.confirmNextNode(prevSendAcc, messageData, messageLengths, ethers_1.BigNumber.from(prevSendCount).add(sends.length), afterlogAcc, afterLogCount);
    }
    rejectNextNode(stakerAddress) {
        return this.rollup.rejectNextNode(stakerAddress);
    }
    async createChallenge(staker1Address, nodeNum1, staker2Address, nodeNum2, node1, node2) {
        return this.rollup.createChallenge([staker1Address, staker2Address], [nodeNum1, nodeNum2], [node1.executionHash(), node2.executionHash()], [node1.afterState.proposedBlock, node2.afterState.proposedBlock], [
            node1.afterState.execState.inboxCount,
            node2.afterState.execState.inboxCount,
        ]);
    }
    addToDeposit(staker, overrides = {}) {
        return this.rollup.addToDeposit(staker, overrides);
    }
    reduceDeposit(amount) {
        return this.rollup.reduceDeposit(amount);
    }
    returnOldDeposit(stakerAddress) {
        return this.rollup.returnOldDeposit(stakerAddress);
    }
    // removeZombieStaker(
    //   nodeNum: BigNumberish,
    //   stakerAddress: string
    // ): Promise<ContractTransaction> {
    //   return this.rollup.removeZombieStaker(nodeNum, stakerAddress)
    // }
    latestConfirmed() {
        return this.rollup.latestConfirmed();
    }
    getNode(index) {
        return this.rollup.getNode(index);
    }
    // async inboxMaxValue(): Promise<BytesLike> {
    //   const bridgeAddress = await this.rollup.delayedBridge()
    //   const Bridge = await ethers.getContractFactory('Bridge')
    //   const bridge = Bridge.attach(bridgeAddress) as Bridge
    //   const inboxInfo = await bridge.inboxInfo()
    //   return inboxInfo[1]
    // }
    currentRequiredStake() {
        return this.rollup.currentRequiredStake();
    }
}
exports.RollupContract = RollupContract;
