import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export declare type GlobalStateStruct = {
    bytes32Vals: [BytesLike, BytesLike];
    u64Vals: [BigNumberish, BigNumberish];
};
export declare type GlobalStateStructOutput = [
    [
        string,
        string
    ],
    [
        BigNumber,
        BigNumber
    ]
] & {
    bytes32Vals: [string, string];
    u64Vals: [BigNumber, BigNumber];
};
export declare type NodeStruct = {
    stateHash: BytesLike;
    challengeHash: BytesLike;
    confirmData: BytesLike;
    prevNum: BigNumberish;
    deadlineBlock: BigNumberish;
    noChildConfirmedBeforeBlock: BigNumberish;
    stakerCount: BigNumberish;
    childStakerCount: BigNumberish;
    firstChildBlock: BigNumberish;
    latestChildNumber: BigNumberish;
    createdAtBlock: BigNumberish;
    nodeHash: BytesLike;
};
export declare type NodeStructOutput = [
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
] & {
    stateHash: string;
    challengeHash: string;
    confirmData: string;
    prevNum: BigNumber;
    deadlineBlock: BigNumber;
    noChildConfirmedBeforeBlock: BigNumber;
    stakerCount: BigNumber;
    childStakerCount: BigNumber;
    firstChildBlock: BigNumber;
    latestChildNumber: BigNumber;
    createdAtBlock: BigNumber;
    nodeHash: string;
};
export declare namespace RollupLib {
    type ExecutionStateStruct = {
        globalState: GlobalStateStruct;
        machineStatus: BigNumberish;
    };
    type ExecutionStateStructOutput = [GlobalStateStructOutput, number] & {
        globalState: GlobalStateStructOutput;
        machineStatus: number;
    };
    type AssertionStruct = {
        beforeState: RollupLib.ExecutionStateStruct;
        afterState: RollupLib.ExecutionStateStruct;
        numBlocks: BigNumberish;
    };
    type AssertionStructOutput = [
        RollupLib.ExecutionStateStructOutput,
        RollupLib.ExecutionStateStructOutput,
        BigNumber
    ] & {
        beforeState: RollupLib.ExecutionStateStructOutput;
        afterState: RollupLib.ExecutionStateStructOutput;
        numBlocks: BigNumber;
    };
}
export declare namespace IRollupCore {
    type StakerStruct = {
        amountStaked: BigNumberish;
        index: BigNumberish;
        latestStakedNode: BigNumberish;
        currentChallenge: BigNumberish;
        isStaked: boolean;
    };
    type StakerStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
    ] & {
        amountStaked: BigNumber;
        index: BigNumber;
        latestStakedNode: BigNumber;
        currentChallenge: BigNumber;
        isStaked: boolean;
    };
}
export interface IRollupUserAbsInterface extends utils.Interface {
    contractName: "IRollupUserAbs";
    functions: {
        "amountStaked(address)": FunctionFragment;
        "challengeManager()": FunctionFragment;
        "countStakedZombies(uint64)": FunctionFragment;
        "countZombiesStakedOnChildren(uint64)": FunctionFragment;
        "currentChallenge(address)": FunctionFragment;
        "firstUnresolvedNode()": FunctionFragment;
        "getNode(uint64)": FunctionFragment;
        "getStaker(address)": FunctionFragment;
        "getStakerAddress(uint64)": FunctionFragment;
        "initialize(address)": FunctionFragment;
        "isERC20Enabled()": FunctionFragment;
        "isStaked(address)": FunctionFragment;
        "isZombie(address)": FunctionFragment;
        "lastStakeBlock()": FunctionFragment;
        "latestConfirmed()": FunctionFragment;
        "latestNodeCreated()": FunctionFragment;
        "latestStakedNode(address)": FunctionFragment;
        "nodeHasStaker(uint64,address)": FunctionFragment;
        "requireUnresolved(uint256)": FunctionFragment;
        "requireUnresolvedExists()": FunctionFragment;
        "returnOldDeposit(address)": FunctionFragment;
        "stakerCount()": FunctionFragment;
        "withdrawableFunds(address)": FunctionFragment;
        "zombieAddress(uint256)": FunctionFragment;
        "zombieCount()": FunctionFragment;
        "zombieLatestStakedNode(uint256)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "amountStaked", values: [string]): string;
    encodeFunctionData(functionFragment: "challengeManager", values?: undefined): string;
    encodeFunctionData(functionFragment: "countStakedZombies", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "countZombiesStakedOnChildren", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "currentChallenge", values: [string]): string;
    encodeFunctionData(functionFragment: "firstUnresolvedNode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNode", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "getStaker", values: [string]): string;
    encodeFunctionData(functionFragment: "getStakerAddress", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "initialize", values: [string]): string;
    encodeFunctionData(functionFragment: "isERC20Enabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isStaked", values: [string]): string;
    encodeFunctionData(functionFragment: "isZombie", values: [string]): string;
    encodeFunctionData(functionFragment: "lastStakeBlock", values?: undefined): string;
    encodeFunctionData(functionFragment: "latestConfirmed", values?: undefined): string;
    encodeFunctionData(functionFragment: "latestNodeCreated", values?: undefined): string;
    encodeFunctionData(functionFragment: "latestStakedNode", values: [string]): string;
    encodeFunctionData(functionFragment: "nodeHasStaker", values: [BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "requireUnresolved", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "requireUnresolvedExists", values?: undefined): string;
    encodeFunctionData(functionFragment: "returnOldDeposit", values: [string]): string;
    encodeFunctionData(functionFragment: "stakerCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "withdrawableFunds", values: [string]): string;
    encodeFunctionData(functionFragment: "zombieAddress", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "zombieCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "zombieLatestStakedNode", values: [BigNumberish]): string;
    decodeFunctionResult(functionFragment: "amountStaked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "challengeManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "countStakedZombies", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "countZombiesStakedOnChildren", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "currentChallenge", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "firstUnresolvedNode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getStaker", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getStakerAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isERC20Enabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isStaked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isZombie", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lastStakeBlock", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "latestConfirmed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "latestNodeCreated", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "latestStakedNode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nodeHasStaker", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "requireUnresolved", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "requireUnresolvedExists", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "returnOldDeposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stakerCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawableFunds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "zombieAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "zombieCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "zombieLatestStakedNode", data: BytesLike): Result;
    events: {
        "NodeConfirmed(uint64,bytes32,bytes32)": EventFragment;
        "NodeCreated(uint64,bytes32,bytes32,bytes32,tuple,bytes32,bytes32,uint256)": EventFragment;
        "NodeRejected(uint64)": EventFragment;
        "RollupChallengeStarted(uint64,address,address,uint64)": EventFragment;
        "RollupInitialized(bytes32,uint256)": EventFragment;
        "UserStakeUpdated(address,uint256,uint256)": EventFragment;
        "UserWithdrawableFundsUpdated(address,uint256,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "NodeConfirmed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NodeCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NodeRejected"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RollupChallengeStarted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RollupInitialized"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UserStakeUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UserWithdrawableFundsUpdated"): EventFragment;
}
export declare type NodeConfirmedEvent = TypedEvent<[
    BigNumber,
    string,
    string
], {
    nodeNum: BigNumber;
    blockHash: string;
    sendRoot: string;
}>;
export declare type NodeConfirmedEventFilter = TypedEventFilter<NodeConfirmedEvent>;
export declare type NodeCreatedEvent = TypedEvent<[
    BigNumber,
    string,
    string,
    string,
    RollupLib.AssertionStructOutput,
    string,
    string,
    BigNumber
], {
    nodeNum: BigNumber;
    parentNodeHash: string;
    nodeHash: string;
    executionHash: string;
    assertion: RollupLib.AssertionStructOutput;
    afterInboxBatchAcc: string;
    wasmModuleRoot: string;
    inboxMaxCount: BigNumber;
}>;
export declare type NodeCreatedEventFilter = TypedEventFilter<NodeCreatedEvent>;
export declare type NodeRejectedEvent = TypedEvent<[BigNumber], {
    nodeNum: BigNumber;
}>;
export declare type NodeRejectedEventFilter = TypedEventFilter<NodeRejectedEvent>;
export declare type RollupChallengeStartedEvent = TypedEvent<[
    BigNumber,
    string,
    string,
    BigNumber
], {
    challengeIndex: BigNumber;
    asserter: string;
    challenger: string;
    challengedNode: BigNumber;
}>;
export declare type RollupChallengeStartedEventFilter = TypedEventFilter<RollupChallengeStartedEvent>;
export declare type RollupInitializedEvent = TypedEvent<[
    string,
    BigNumber
], {
    machineHash: string;
    chainId: BigNumber;
}>;
export declare type RollupInitializedEventFilter = TypedEventFilter<RollupInitializedEvent>;
export declare type UserStakeUpdatedEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber
], {
    user: string;
    initialBalance: BigNumber;
    finalBalance: BigNumber;
}>;
export declare type UserStakeUpdatedEventFilter = TypedEventFilter<UserStakeUpdatedEvent>;
export declare type UserWithdrawableFundsUpdatedEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber
], {
    user: string;
    initialBalance: BigNumber;
    finalBalance: BigNumber;
}>;
export declare type UserWithdrawableFundsUpdatedEventFilter = TypedEventFilter<UserWithdrawableFundsUpdatedEvent>;
export interface IRollupUserAbs extends BaseContract {
    contractName: "IRollupUserAbs";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IRollupUserAbsInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        amountStaked(staker: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        challengeManager(overrides?: CallOverrides): Promise<[string]>;
        countStakedZombies(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
        countZombiesStakedOnChildren(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<[BigNumber]>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<[NodeStructOutput]>;
        getStaker(staker: string, overrides?: CallOverrides): Promise<[IRollupCore.StakerStructOutput]>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        initialize(stakeToken: string, overrides?: CallOverrides): Promise<[void]>;
        isERC20Enabled(overrides?: CallOverrides): Promise<[boolean]>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<[boolean]>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<[boolean]>;
        lastStakeBlock(overrides?: CallOverrides): Promise<[BigNumber]>;
        latestConfirmed(overrides?: CallOverrides): Promise<[BigNumber]>;
        latestNodeCreated(overrides?: CallOverrides): Promise<[BigNumber]>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        nodeHasStaker(nodeNum: BigNumberish, staker: string, overrides?: CallOverrides): Promise<[boolean]>;
        requireUnresolved(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<[void]>;
        requireUnresolvedExists(overrides?: CallOverrides): Promise<[void]>;
        returnOldDeposit(stakerAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        stakerCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        zombieCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
    };
    amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
    challengeManager(overrides?: CallOverrides): Promise<string>;
    countStakedZombies(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    countZombiesStakedOnChildren(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    currentChallenge(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
    firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;
    getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<NodeStructOutput>;
    getStaker(staker: string, overrides?: CallOverrides): Promise<IRollupCore.StakerStructOutput>;
    getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
    initialize(stakeToken: string, overrides?: CallOverrides): Promise<void>;
    isERC20Enabled(overrides?: CallOverrides): Promise<boolean>;
    isStaked(staker: string, overrides?: CallOverrides): Promise<boolean>;
    isZombie(staker: string, overrides?: CallOverrides): Promise<boolean>;
    lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;
    latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;
    latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;
    latestStakedNode(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
    nodeHasStaker(nodeNum: BigNumberish, staker: string, overrides?: CallOverrides): Promise<boolean>;
    requireUnresolved(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<void>;
    requireUnresolvedExists(overrides?: CallOverrides): Promise<void>;
    returnOldDeposit(stakerAddress: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    stakerCount(overrides?: CallOverrides): Promise<BigNumber>;
    withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
    zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
    zombieCount(overrides?: CallOverrides): Promise<BigNumber>;
    zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    callStatic: {
        amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        challengeManager(overrides?: CallOverrides): Promise<string>;
        countStakedZombies(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        countZombiesStakedOnChildren(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<NodeStructOutput>;
        getStaker(staker: string, overrides?: CallOverrides): Promise<IRollupCore.StakerStructOutput>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
        initialize(stakeToken: string, overrides?: CallOverrides): Promise<void>;
        isERC20Enabled(overrides?: CallOverrides): Promise<boolean>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<boolean>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<boolean>;
        lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;
        latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;
        latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        nodeHasStaker(nodeNum: BigNumberish, staker: string, overrides?: CallOverrides): Promise<boolean>;
        requireUnresolved(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<void>;
        requireUnresolvedExists(overrides?: CallOverrides): Promise<void>;
        returnOldDeposit(stakerAddress: string, overrides?: CallOverrides): Promise<void>;
        stakerCount(overrides?: CallOverrides): Promise<BigNumber>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
        zombieCount(overrides?: CallOverrides): Promise<BigNumber>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "NodeConfirmed(uint64,bytes32,bytes32)"(nodeNum?: BigNumberish | null, blockHash?: null, sendRoot?: null): NodeConfirmedEventFilter;
        NodeConfirmed(nodeNum?: BigNumberish | null, blockHash?: null, sendRoot?: null): NodeConfirmedEventFilter;
        "NodeCreated(uint64,bytes32,bytes32,bytes32,tuple,bytes32,bytes32,uint256)"(nodeNum?: BigNumberish | null, parentNodeHash?: BytesLike | null, nodeHash?: BytesLike | null, executionHash?: null, assertion?: null, afterInboxBatchAcc?: null, wasmModuleRoot?: null, inboxMaxCount?: null): NodeCreatedEventFilter;
        NodeCreated(nodeNum?: BigNumberish | null, parentNodeHash?: BytesLike | null, nodeHash?: BytesLike | null, executionHash?: null, assertion?: null, afterInboxBatchAcc?: null, wasmModuleRoot?: null, inboxMaxCount?: null): NodeCreatedEventFilter;
        "NodeRejected(uint64)"(nodeNum?: BigNumberish | null): NodeRejectedEventFilter;
        NodeRejected(nodeNum?: BigNumberish | null): NodeRejectedEventFilter;
        "RollupChallengeStarted(uint64,address,address,uint64)"(challengeIndex?: BigNumberish | null, asserter?: null, challenger?: null, challengedNode?: null): RollupChallengeStartedEventFilter;
        RollupChallengeStarted(challengeIndex?: BigNumberish | null, asserter?: null, challenger?: null, challengedNode?: null): RollupChallengeStartedEventFilter;
        "RollupInitialized(bytes32,uint256)"(machineHash?: null, chainId?: null): RollupInitializedEventFilter;
        RollupInitialized(machineHash?: null, chainId?: null): RollupInitializedEventFilter;
        "UserStakeUpdated(address,uint256,uint256)"(user?: string | null, initialBalance?: null, finalBalance?: null): UserStakeUpdatedEventFilter;
        UserStakeUpdated(user?: string | null, initialBalance?: null, finalBalance?: null): UserStakeUpdatedEventFilter;
        "UserWithdrawableFundsUpdated(address,uint256,uint256)"(user?: string | null, initialBalance?: null, finalBalance?: null): UserWithdrawableFundsUpdatedEventFilter;
        UserWithdrawableFundsUpdated(user?: string | null, initialBalance?: null, finalBalance?: null): UserWithdrawableFundsUpdatedEventFilter;
    };
    estimateGas: {
        amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        challengeManager(overrides?: CallOverrides): Promise<BigNumber>;
        countStakedZombies(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        countZombiesStakedOnChildren(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getStaker(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(stakeToken: string, overrides?: CallOverrides): Promise<BigNumber>;
        isERC20Enabled(overrides?: CallOverrides): Promise<BigNumber>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;
        latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;
        latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        nodeHasStaker(nodeNum: BigNumberish, staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        requireUnresolved(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        requireUnresolvedExists(overrides?: CallOverrides): Promise<BigNumber>;
        returnOldDeposit(stakerAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        stakerCount(overrides?: CallOverrides): Promise<BigNumber>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        zombieCount(overrides?: CallOverrides): Promise<BigNumber>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        amountStaked(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        challengeManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        countStakedZombies(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        countZombiesStakedOnChildren(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getStaker(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(stakeToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isERC20Enabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lastStakeBlock(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        latestConfirmed(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        latestNodeCreated(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nodeHasStaker(nodeNum: BigNumberish, staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        requireUnresolved(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        requireUnresolvedExists(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        returnOldDeposit(stakerAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        stakerCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        zombieCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
