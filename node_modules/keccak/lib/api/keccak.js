<<<<<<< HEAD
const { Transform } = require('readable-stream')

module.exports = (KeccakState) => class Keccak extends Transform {
  constructor (rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options)
=======
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

module.exports = function (KeccakState) {
  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {
    Transform.call(this, options)
>>>>>>> ba11e9b4e (Initial commit after reset)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

<<<<<<< HEAD
  _transform (chunk, encoding, callback) {
    let error = null
=======
  inherits(Keccak, Transform)

  Keccak.prototype._transform = function (chunk, encoding, callback) {
    var error = null
>>>>>>> ba11e9b4e (Initial commit after reset)
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

<<<<<<< HEAD
  _flush (callback) {
    let error = null
=======
  Keccak.prototype._flush = function (callback) {
    var error = null
>>>>>>> ba11e9b4e (Initial commit after reset)
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

<<<<<<< HEAD
  update (data, encoding) {
=======
  Keccak.prototype.update = function (data, encoding) {
>>>>>>> ba11e9b4e (Initial commit after reset)
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

<<<<<<< HEAD
  digest (encoding) {
=======
  Keccak.prototype.digest = function (encoding) {
>>>>>>> ba11e9b4e (Initial commit after reset)
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
<<<<<<< HEAD
    let digest = this._state.squeeze(this._hashBitLength / 8)
=======
    var digest = this._state.squeeze(this._hashBitLength / 8)
>>>>>>> ba11e9b4e (Initial commit after reset)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
<<<<<<< HEAD
  _resetState () {
=======
  Keccak.prototype._resetState = function () {
>>>>>>> ba11e9b4e (Initial commit after reset)
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
<<<<<<< HEAD
  _clone () {
    const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
=======
  Keccak.prototype._clone = function () {
    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
>>>>>>> ba11e9b4e (Initial commit after reset)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }
<<<<<<< HEAD
=======

  return Keccak
>>>>>>> ba11e9b4e (Initial commit after reset)
}
