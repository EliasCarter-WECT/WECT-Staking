<<<<<<< HEAD
#include <napi.h>

extern "C" {
#include <KeccakSpongeWidth1600.h>
}

class KeccakWrapper : public Napi::ObjectWrap<KeccakWrapper> {
 public:
  static Napi::Object Init(Napi::Env env);

  KeccakWrapper(const Napi::CallbackInfo& info);

 private:
  KeccakWidth1600_SpongeInstance sponge;

  Napi::Value Initialize(const Napi::CallbackInfo& info);
  Napi::Value Absorb(const Napi::CallbackInfo& info);
  Napi::Value AbsorbLastFewBits(const Napi::CallbackInfo& info);
  Napi::Value Squeeze(const Napi::CallbackInfo& info);
  Napi::Value Copy(const Napi::CallbackInfo& info);
};

Napi::Object KeccakWrapper::Init(Napi::Env env) {
  Napi::Function func =
      DefineClass(env,
                  "KeccakWrapper",
                  {
                      InstanceMethod("initialize", &KeccakWrapper::Initialize),
                      InstanceMethod("absorb", &KeccakWrapper::Absorb),
                      InstanceMethod("absorbLastFewBits",
                                     &KeccakWrapper::AbsorbLastFewBits),
                      InstanceMethod("squeeze", &KeccakWrapper::Squeeze),
                      InstanceMethod("copy", &KeccakWrapper::Copy),
                  });

  return func;
}

KeccakWrapper::KeccakWrapper(const Napi::CallbackInfo& info)
    : Napi::ObjectWrap<KeccakWrapper>(info) {}

Napi::Value KeccakWrapper::Initialize(const Napi::CallbackInfo& info) {
  auto rate = info[0].As<Napi::Number>().Uint32Value();
  auto capacity = info[1].As<Napi::Number>().Uint32Value();

  // ignore return code,
  // rate & capacity always will right because internal object
  KeccakWidth1600_SpongeInitialize(&sponge, rate, capacity);

  return info.Env().Undefined();
}

Napi::Value KeccakWrapper::Absorb(const Napi::CallbackInfo& info) {
  auto buf = info[0].As<Napi::Buffer<const unsigned char>>();

  // ignore return code, bcause internal object
  KeccakWidth1600_SpongeAbsorb(&sponge, buf.Data(), buf.Length());

  return info.Env().Undefined();
}

Napi::Value KeccakWrapper::AbsorbLastFewBits(const Napi::CallbackInfo& info) {
  auto bits = info[0].As<Napi::Number>().Uint32Value();

  // ignore return code, bcause internal object
  KeccakWidth1600_SpongeAbsorbLastFewBits(&sponge, bits);

  return info.Env().Undefined();
}

Napi::Value KeccakWrapper::Squeeze(const Napi::CallbackInfo& info) {
  auto length = info[0].As<Napi::Number>().Uint32Value();
  auto buf = Napi::Buffer<unsigned char>::New(info.Env(), length);

  KeccakWidth1600_SpongeSqueeze(&sponge, buf.Data(), length);

  return buf;
}

Napi::Value KeccakWrapper::Copy(const Napi::CallbackInfo& info) {
  auto to = Napi::ObjectWrap<KeccakWrapper>::Unwrap(info[0].As<Napi::Object>());

  memcpy(&to->sponge, &sponge, sizeof(KeccakWidth1600_SpongeInstance));

  return info.Env().Undefined();
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
  return KeccakWrapper::Init(env);
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)
=======
#include <node.h>
#include <nan.h>

extern "C" {
  #include "libkeccak/KeccakSponge.h"
}

class KeccakWrapper : public Nan::ObjectWrap {
 public:
  static v8::Local<v8::Function> Init () {
    Nan::EscapableHandleScope scope;

    v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
    tpl->SetClassName(Nan::New("KeccakWrapper").ToLocalChecked());
    tpl->InstanceTemplate()->SetInternalFieldCount(1);

    Nan::SetPrototypeMethod(tpl, "initialize", Initialize);
    Nan::SetPrototypeMethod(tpl, "absorb", Absorb);
    Nan::SetPrototypeMethod(tpl, "absorbLastFewBits", AbsorbLastFewBits);
    Nan::SetPrototypeMethod(tpl, "squeeze", Squeeze);
    Nan::SetPrototypeMethod(tpl, "copy", Copy);

    return scope.Escape(Nan::GetFunction(tpl).ToLocalChecked());
  }

 private:
  KeccakWidth1600_SpongeInstance sponge;

  static NAN_METHOD(New) {
    KeccakWrapper* obj = new KeccakWrapper();
    obj->Wrap(info.This());
    info.GetReturnValue().Set(info.This());
  }

  static NAN_METHOD(Initialize) {
    KeccakWrapper* obj = Nan::ObjectWrap::Unwrap<KeccakWrapper>(info.Holder());
    unsigned int rate = info[0]->IntegerValue();
    unsigned int capacity = info[1]->IntegerValue();

    // ignore return code, rate & capacity always will right because internal object
    KeccakWidth1600_SpongeInitialize(&obj->sponge, rate, capacity);
  }

  static NAN_METHOD(Absorb) {
    KeccakWrapper* obj = Nan::ObjectWrap::Unwrap<KeccakWrapper>(info.Holder());
    v8::Local<v8::Object> buffer = info[0].As<v8::Object>();
    const unsigned char* data = (const unsigned char*) node::Buffer::Data(buffer);
    size_t length = node::Buffer::Length(buffer);

    // ignore return code, bcause internal object
    KeccakWidth1600_SpongeAbsorb(&obj->sponge, data, length);
  }

  static NAN_METHOD(AbsorbLastFewBits) {
    KeccakWrapper* obj = Nan::ObjectWrap::Unwrap<KeccakWrapper>(info.Holder());
    unsigned char bits = info[0]->IntegerValue();

    // ignore return code, bcause internal object
    KeccakWidth1600_SpongeAbsorbLastFewBits(&obj->sponge, bits);
  }

  static NAN_METHOD(Squeeze) {
    KeccakWrapper* obj = Nan::ObjectWrap::Unwrap<KeccakWrapper>(info.Holder());
    size_t length = info[0]->IntegerValue();

    v8::Local<v8::Object> buffer = Nan::NewBuffer(length).ToLocalChecked();
    unsigned char* data = (unsigned char*) node::Buffer::Data(buffer);

    KeccakWidth1600_SpongeSqueeze(&obj->sponge, data, length);
    info.GetReturnValue().Set(buffer);
  }

  static NAN_METHOD(Copy) {
    KeccakWrapper* from = Nan::ObjectWrap::Unwrap<KeccakWrapper>(info.Holder());
    KeccakWrapper* to = Nan::ObjectWrap::Unwrap<KeccakWrapper>(info[0]->ToObject());

    memcpy(&to->sponge, &from->sponge, sizeof(KeccakWidth1600_SpongeInstance));
  }
};

void Init(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE exports, Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE module) {
  // I wish to use pure functions, but we need wrapper around state (KeccakWidth1600_SpongeInstance)
  Nan::Set(module, Nan::New("exports").ToLocalChecked(), KeccakWrapper::Init());
}

NODE_MODULE(keccak, Init)
>>>>>>> ba11e9b4e (Initial commit after reset)
